package com.example.fun4demo.Controller;

import com.example.fun4demo.Model.Account;

import com.example.fun4demo.Repository.AccountRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import javax.validation.Valid;
import java.util.List;
import java.util.Optional;

@CrossOrigin( maxAge = 3600, allowedHeaders = "*")
@RestController
@Configuration
@RequestMapping(path="/account") // This means URL's start with /demo (after Application path)
public class AccountController {
    @Autowired // This means to get the bean called userRepository
    // Which is auto-generated by Spring, we will use it to handle the data
    private AccountRepository accountRepository;


    @GetMapping
    public @ResponseBody Iterable<Account> getAllAccount() {
        // This returns a JSON or XML with the users
        return accountRepository.findAll();

    }
    @GetMapping(value = {"/{id}"})
    public @ResponseBody
    Account getAccount(@PathVariable Long id){
        return accountRepository.findById(id).get();
    }

    @PostMapping("/login")

    public @ResponseBody
    Optional<Account> getAccountId   (  @RequestBody Account inlogAccount) {
        //Account a = new Account();
        //Account validEmail = accountRepository.findByEmail(inlogAccount.getEmail());
        //Account validPassword = accountRepository.findByPassword(inlogAccount.getPassword());

        List<Account> accounts = accountRepository.findAll();
        for (Account acc : accounts) {
            if (acc.getEmail().equals(inlogAccount.getEmail()) && acc.getPassword().equals(inlogAccount.getPassword())) {
                Long id = acc.getId();
                return accountRepository.findById(id)  ;
            }

        }

        return Optional.empty();
    }






    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public @ResponseBody ResponseEntity addNewAccount (@Valid @RequestBody Account account
    ) {


        Account a = new Account();
        Account emailExist = accountRepository.findByEmail(account.getEmail());
        if (emailExist != null) return new ResponseEntity<>(HttpStatus.CONFLICT);
        else
            accountRepository.save(account);
        return new ResponseEntity<>(HttpStatus.CREATED);






        //return "{Saved}"; // TODO 2 mogelijkheden: het bestond al, of is nieuw aangemaakt.
        // TODO 3 voorlopig mag je van mij hier een json response teruggeven, maar het is veel netter om met HTTP status codes te werken.
    }
    @PutMapping(value = {"/{id}"})
    public Account updateAccount (@PathVariable Long id , @Valid @RequestBody Account accountUpdate){
        return accountRepository.findById(id).map(account->
        {
            if (accountUpdate.getFirstName() == null){
                account.setFirstName(account.getFirstName());
            }
            else {
                account.setFirstName(accountUpdate.getFirstName());
            }
            if (accountUpdate.getLastName() == null){
                account.setLastName(account.getLastName());
            }
            else {
                account.setLastName(accountUpdate.getLastName());
            }
            if (accountUpdate.getStaffMember() == null){
                account.setStaffMember(account.getStaffMember());
            }
            else {
                account.setStaffMember(accountUpdate.getStaffMember());
            }
            account.setEmail(account.getEmail());
            account.setPassword(account.getPassword());
            return accountRepository.save(account);
        }).orElseThrow();


    }

    @DeleteMapping(value = "/{id}")
    public String deleteAccount(@PathVariable long id) {
        accountRepository.deleteById(id);

        return id + " is succesfully deleted";
    }




}
