package com.example.fun4demo.Controller;

import com.example.fun4demo.Model.Account;
import com.example.fun4demo.Repository.AccountRepository;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import javax.validation.Valid;

@CrossOrigin( maxAge = 3600, allowedHeaders = "*")
@RestController
@RequestMapping(path="/account") // This means URL's start with /demo (after Application path)
public class AccountController {
    @Autowired // This means to get the bean called userRepository
    // Which is auto-generated by Spring, we will use it to handle the data
    private AccountRepository accountRepository;


    @GetMapping
    public @ResponseBody Iterable<Account> getAllAccount() {
        // This returns a JSON or XML with the users
        return accountRepository.findAll();

    }
    @GetMapping(value = {"/{id}"})
    public @ResponseBody
    Account getAccount(@PathVariable Long id){
        return accountRepository.findById(id).get();
    }
    @PostMapping
    public @ResponseBody String addNewAccount (@Valid @RequestBody Account account
    ) {
        // TODO 2) het is altijd de backend die de controles doet.

        Account a = new Account();
        Account emailExist = accountRepository.findByEmail(account.getEmail());
        if (emailExist != null){
            new ResponseEntity<>(HttpStatus.CONFLICT);
        }
        else{
            accountRepository.save(account);
            new ResponseEntity<>(HttpStatus.CREATED);
        }



        return "{Saved}"; // TODO 2 mogelijkheden: het bestond al, of is nieuw aangemaakt.
        // TODO 3 voorlopig mag je van mij hier een json response teruggeven, maar het is veel netter om met HTTP status codes te werken.
    }
    @PutMapping(value = "/{id}")
    public Account updateAccount (@PathVariable Long id , @Valid @RequestBody Account accountUpdate){
        return accountRepository.findById(id).map(account->{
            account.setFirstName(accountUpdate.getFirstName());
            account.setLastName(accountUpdate.getLastName());
            account.setStaffMember(accountUpdate.getStaffMember());
            account.setEmail(accountUpdate.getEmail());
            account.setPassword(accountUpdate.getPassword());
            return accountRepository.save(account);
        }).orElseThrow();


    }

    @DeleteMapping(value = "/{id}")
    public String deleteAccount(@PathVariable long id) {
        accountRepository.deleteById(id);

        return id + " is succesfully deleted";
    }




}
