package com.example.fun4demo.Controller;

import com.example.fun4demo.Model.Account;
import com.example.fun4demo.Repository.AccountRepository;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import javax.validation.Valid;

@CrossOrigin( maxAge = 3600, allowedHeaders = "*")
@RestController
@RequestMapping(path="/account") // This means URL's start with /demo (after Application path)
public class AccountController {
    @Autowired // This means to get the bean called userRepository
    // Which is auto-generated by Spring, we will use it to handle the data
    private AccountRepository accountRepository;


    @GetMapping
    public @ResponseBody Iterable<Account> getAllAccount() {
        // This returns a JSON or XML with the users
        return accountRepository.findAll();

    }
    @GetMapping(value = {"/{id}"})
    public @ResponseBody
    Account getAccount(@PathVariable Long id){
        return accountRepository.findById(id).get();
    }
    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public @ResponseBody ResponseEntity addNewAccount (@Valid @RequestBody Account account
    ) {
        // TODO 2) het is altijd de backend die de controles doet.

        Account a = new Account();
        Account emailExist = accountRepository.findByEmail(account.getEmail());
        if (emailExist != null){
            return new ResponseEntity(HttpStatus.CONFLICT);

        }
        else{
            accountRepository.save(account);
            return new ResponseEntity<>(HttpStatus.CREATED);


        }



        //return "{Saved}"; // TODO 2 mogelijkheden: het bestond al, of is nieuw aangemaakt.
        // TODO 3 voorlopig mag je van mij hier een json response teruggeven, maar het is veel netter om met HTTP status codes te werken.
    }
    @PutMapping(value = {"/{id}"})
    public Account updateAccount (@PathVariable Long id , @Valid @RequestBody Account accountUpdate){
        return accountRepository.findById(id).map(account->
        {
            if (accountUpdate.getFirstName() == null){
                account.setFirstName(account.getFirstName());
            }
            else {
                account.setFirstName(accountUpdate.getFirstName());
            }
            if (accountUpdate.getLastName() == null){
                account.setLastName(account.getLastName());
            }
            else {
                account.setLastName(accountUpdate.getLastName());
            }
            if (accountUpdate.getStaffMember() == null){
                account.setStaffMember(account.getStaffMember());
            }
            else {
                account.setStaffMember(accountUpdate.getStaffMember());
            }
            account.setEmail(account.getEmail());
            account.setPassword(account.getPassword());
            return accountRepository.save(account);
        }).orElseThrow();


    }

    @DeleteMapping(value = "/{id}")
    public String deleteAccount(@PathVariable long id) {
        accountRepository.deleteById(id);

        return id + " is succesfully deleted";
    }




}
